require "test_helper"
require "#{Rails.root}/plugins/pairwise/test/fixtures/pairwise_content_fixtures"
require "#{Rails.root}/plugins/pairwise/test/fixtures/http_stub_fixtures"

# require 'vcr'

# VCR.configure do |c|
#   c.cassette_library_dir = "#{Rails.root}/plugins/pairwise/test/fixtures/vcr_cassettes"
#   c.hook_into :webmock
#   c.before_playback do |i|
#     puts "I in PLAYBACK: #{i.inspect}"
#   end
# end

class PairwisePlugin::PairwiseContentTest < ActiveSupport::TestCase

 fixtures :environments

  def setup
     pairwise_env_settings = { :api_host => "http://localhost:3030/",
                                :username => "abner.oliveira@serpro.gov.br", 
                                :password => "serpro"
                              }
    @profile = create_user('testing').person
    @profile.environment = environments(:colivre_net)
    @pairwise_client = Pairwise::Client.build(1, pairwise_env_settings)
    @pairwise_content = PairwiseContentFixtures.pairwise_content
    @pairwise_content.profile = @profile
    #PairwisePlugin::PairwiseContent.any_instance.stubs(:send_question_to_service).returns(true)
    #PairwisePlugin::PairwiseContent.any_instance.stubs(:pairwise_client).returns(@pairwise_client)
    @http_stub_fixtures = HttpStubFixtures.new(pairwise_env_settings)
  end

  should 'be inactive when created' do
    assert_equal false, @pairwise_content.published?
  end

  should 'get question from stubed api call' do
    question = @http_stub_fixtures.create_question(2, 'Question 2', 'Choice X\nChoice Y')
    assert_not_nil question
    assert_equal 2, question.id
    assert_equal 'Question 2', question.name  
  end

  should 'provide proper short description' do
    assert_equal 'Pairwise question', PairwisePlugin::PairwiseContent.short_description
  end

  should 'provide proper description' do
    assert_equal 'Question managed by pairwise', PairwisePlugin::PairwiseContent.description
  end

  should 'have an html view' do
    assert_not_nil @pairwise_content.to_html
  end

  should 'have result_url' do
    assert_not_nil @pairwise_content.result_url
    assert_equal @pairwise_content.profile.identifier, @pairwise_content.result_url[:profile]
    assert_equal :pairwise_plugin_profile, @pairwise_content.result_url[:controller]
    assert_equal :result, @pairwise_content.result_url[:action]
  end

  should 'get question from pairwise service' do
    @question = Pairwise::Question.new(:id => @pairwise_content.pairwise_question_id, :name => 'Question 1')
    @pairwise_content.expects(:pairwise_client).returns(@pairwise_client)
    @pairwise_client.expects(:find_question_by_id).with(@question.id).returns(@question)
    assert_equal @question, @pairwise_content.question
  end

  should 'prepare prompt' do
    @question = Pairwise::Question.new(:id => @pairwise_content.pairwise_question_id, :name => 'Question 1')
    @pairwise_content.expects(:pairwise_client).returns(@pairwise_client).at_least_once
    @pairwise_client.expects(:question_with_prompt).with(@question.id,'any_user', nil).returns(@question)
    prompt = @pairwise_content.prepare_prompt('any_user')
    assert_not_nil prompt
  end

  should 'add error to base when the question does not exist' do
    Response = Struct.new(:code, :message)   

    @response = Response.new(422, "Any error")

    @pairwise_client.expects(:find_question_by_id).with(@pairwise_content.pairwise_question_id).raises(ActiveResource::ResourceNotFound.new(@response))

    @pairwise_content.expects(:pairwise_client).returns(@pairwise_client)
    assert @pairwise_content.errors[:base].blank?
    @pairwise_content.question

    assert !@pairwise_content.errors[:base].blank?
    assert_match /Any error/, @pairwise_content.errors[:base].first
    assert_match /422/, @pairwise_content.errors[:base].first
  end

  should 'send question to pairwise service' do
    question = Pairwise::Question.new(:id => 3, :name => 'Question 1')
    #expectations
    pairwise_content = PairwiseContentFixtures.new_pairwise_content
    pairwise_content.profile = @profile
    pairwise_content.expects(:valid?).returns(true)  
    pairwise_content.expects(:create_pairwise_question).returns(question)
    pairwise_content.expects(:toggle_autoactivate_ideas).at_least_once
    #save should call before_save which sends the question to pairwise
    pairwise_content.save!
    
    #after save pairwise_question_id should store question id generated by pairwise
    assert_equal question.id, pairwise_content.pairwise_question_id
  end 

  should 'send changes in choices to pairwise service' do
    @question = Pairwise::Question.new(:id => @pairwise_content.pairwise_question_id, :name => 'Question 1', :active => false)
    @pairwise_content.expects(:question).returns(@question).at_least_once
    @pairwise_content.expects(:pairwise_client).returns(@pairwise_client).at_least_once
    @pairwise_content.expects('new_record?').returns(false).at_least_once
    @pairwise_content.expects('valid?').returns(true).at_least_once
    @pairwise_content.choices = []
    @pairwise_content.choices_saved = {'1' => 'Choice 1', '2' => 'Choice 2'}
    #save should call update_choice in pairwise_client for each choice already saved
    @pairwise_client.expects(:update_choice).returns(true).times(2)
    @pairwise_content.save
  end

  should 'send new choices to pairwise_service' do
    @question = Pairwise::Question.new(:id => @pairwise_content.pairwise_question_id, :name => 'Question 1', :active => false)  
    @pairwise_content.expects('new_record?').returns(false).at_least_once
    @pairwise_content.expects('valid?').returns(true).at_least_once

    @pairwise_content.expects(:pairwise_client).returns(@pairwise_client).at_least_once
    @pairwise_content.expects(:question).returns(@question).at_least_once
    @pairwise_content.choices = ['New Choice 1', 'New Choice 2']
    @pairwise_content.choices_saved = []

    @pairwise_client.expects(:approve_choice).returns(true).at_least_once
    choice_stub = Pairwise::Choice.new(:id=> 1, :data => 'txt')
    @pairwise_client.expects(:add_choice).with(@pairwise_content.pairwise_question_id, "New Choice 1").returns(choice_stub)
    @pairwise_client.expects(:add_choice).with(@pairwise_content.pairwise_question_id, "New Choice 2").returns(choice_stub)
    @pairwise_client.expects(:update_question).with(@question.id, @question.name).returns(true)
    @pairwise_content.save
    puts @pairwise_content.errors.full_messages
  end

  should 'allow new ideas by default when created' do
    assert_equal true, @pairwise_content.allow_new_ideas?
  end

  should 'add new ideas suggestions when new ideas are allowed' do
    assert_equal true, @pairwise_content.allow_new_ideas?
    @question = Pairwise::Question.new(:id => @pairwise_content.pairwise_question_id, :name => 'Question 1', :active => false)
    @pairwise_content.expects(:pairwise_client).returns(@pairwise_client).at_least_once
    @pairwise_client.expects(:add_new_idea).with(@question.id, "New idea", nil).returns(true)
    assert_equal true, @pairwise_content.add_new_idea("New idea")
  end

  should 'not add new ideas suggestions when new ideas are not allowed' do
    assert_equal true, @pairwise_content.allow_new_ideas?
    @question = Pairwise::Question.new(:id => @pairwise_content.pairwise_question_id, :name => 'Question 1', :active => false)
    @pairwise_content.allow_new_ideas = false
    assert_equal false, @pairwise_content.add_new_idea("New idea")
  end

   should 'join similar choices' do
     pairwise_content = PairwiseContentFixtures.content_stub_with_3_choices

     assert_equal 3, pairwise_content.question.choices.size

     choices_to_join = pairwise_content.question.choices[1..2].map { |choice| choice.id }
     parent_choice = pairwise_content.question.choices[0].id

     pairwise_content.profile = @profile
     pairwise_content.stubs(:valid? => true)
     pairwise_content.stubs(:send_question_to_service => true)
     pairwise_content.join_choices(choices_to_join, parent_choice, user=nil)
      
     choices_related = PairwisePlugin::ChoicesRelated.related_choices_for(parent_choice)
     assert_equal 2, choices_related.size
     assert_equal 1, choices_related.select { |c| c.choice_id == 2}.size
     assert_equal 1, choices_related.select { |c| c.choice_id == 3 }.size
   end

   # should 'skip prompt' do

   # end

   should 'ask skip prompt reasons' do
    prompt = Pairwise::Prompt.new({"left_choice_text"=>"Choice 1", "right_choice_text"=>"New inactive choice", "left_choice_id"=>1300, "right_choice_id"=>1302, "id"=>194, "tracking"=>nil, "votes_count"=>0}) 
    reasons = @pairwise_content.ask_skip_reasons(prompt)

    assert_not_nil reasons
    assert_equal 7, reasons.size
    
    assert reasons[0].include? PairwisePlugin::PairwiseContent::REASONS_ARRAY[0][:text]
    assert reasons[1].include? PairwisePlugin::PairwiseContent::REASONS_ARRAY[1][:text]
    assert reasons[2].include? PairwisePlugin::PairwiseContent::REASONS_ARRAY[2][:text]
    assert reasons[3].include? PairwisePlugin::PairwiseContent::REASONS_ARRAY[3][:text]
    assert reasons[4].include? PairwisePlugin::PairwiseContent::REASONS_ARRAY[4][:text]
    assert reasons[5].include? PairwisePlugin::PairwiseContent::REASONS_ARRAY[4][:text]
    assert reasons[6].include? PairwisePlugin::PairwiseContent::REASONS_ARRAY[5][:text]
   end
end
